using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
namespace LibMPVSharp
{
    public unsafe partial class Render_gl
    {
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct DrmModeAtomicReq
    {
    }
    
    /// <summary>
    /// <para>For initializing the mpv OpenGL state via MPV_RENDER_PARAM_OPENGL_INIT_PARAMS.</para>
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct MpvOpenglInitParams
    {
        /// <summary>
        /// <para>This retrieves OpenGL function pointers, and will use them in subsequent</para>
        /// <para>operation.</para>
        /// <para>Usually, you can simply call the GL context APIs from this callback (e.g.</para>
        /// <para>glXGetProcAddressARB or wglGetProcAddress), but some APIs do not always</para>
        /// <para>return pointers for all standard functions (even if present); in this</para>
        /// <para>case you have to compensate by looking up these functions yourself when</para>
        /// <para>libmpv wants to resolve them through this callback.</para>
        /// <para>libmpv will not normally attempt to resolve GL functions on its own, nor</para>
        /// <para>does it link to GL libraries directly.</para>
        /// </summary>
        public MpvOpenglInitParams_get_proc_addressCallback get_proc_address;
        /// <summary>
        /// <para>Value passed as ctx parameter to get_proc_address().</para>
        /// </summary>
        public void* get_proc_address_ctx;
    }
    
    /// <summary>
    /// <para>For MPV_RENDER_PARAM_OPENGL_FBO.</para>
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct MpvOpenglFbo
    {
        /// <summary>
        /// <para>Framebuffer object name. This must be either a valid FBO generated by</para>
        /// <para>glGenFramebuffers() that is complete and color-renderable, or 0. If the</para>
        /// <para>value is 0, this refers to the OpenGL default framebuffer.</para>
        /// </summary>
        public int fbo;
        /// <summary>
        /// <para>Valid dimensions. This must refer to the size of the framebuffer. This</para>
        /// <para>must always be set.</para>
        /// </summary>
        public int w;
        /// <summary>
        /// <para>Valid dimensions. This must refer to the size of the framebuffer. This</para>
        /// <para>must always be set.</para>
        /// </summary>
        public int h;
        /// <summary>
        /// <para>Underlying texture internal format (e.g. GL_RGBA8), or 0 if unknown. If</para>
        /// <para>this is the default framebuffer, this can be an equivalent.</para>
        /// </summary>
        public int internal_format;
    }
    
    /// <summary>
    /// <para>Deprecated. For MPV_RENDER_PARAM_DRM_DISPLAY.</para>
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct MpvOpenglDrmParams
    {
        public int fd;
        public int crtc_id;
        public int connector_id;
        public global::LibMPVSharp.DrmModeAtomicReq** atomic_request_ptr;
        public int render_fd;
    }
    
    /// <summary>
    /// <para>For MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE.</para>
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct MpvOpenglDrmDrawSurfaceSize
    {
        /// <summary>
        /// <para>size of the draw plane surface in pixels.</para>
        /// </summary>
        public int width;
        /// <summary>
        /// <para>size of the draw plane surface in pixels.</para>
        /// </summary>
        public int height;
    }
    
    /// <summary>
    /// <para>For MPV_RENDER_PARAM_DRM_DISPLAY_V2.</para>
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe struct MpvOpenglDrmParamsV2
    {
        /// <summary>
        /// <para>DRM fd (int). Set to -1 if invalid.</para>
        /// </summary>
        public int fd;
        /// <summary>
        /// <para>Currently used crtc id</para>
        /// </summary>
        public int crtc_id;
        /// <summary>
        /// <para>Currently used connector id</para>
        /// </summary>
        public int connector_id;
        /// <summary>
        /// <para>Pointer to a drmModeAtomicReq pointer that is being used for the renderloop.</para>
        /// <para>This pointer should hold a pointer to the atomic request pointer</para>
        /// <para>The atomic request pointer is usually changed at every renderloop.</para>
        /// </summary>
        public global::LibMPVSharp.DrmModeAtomicReq** atomic_request_ptr;
        /// <summary>
        /// <para>DRM render node. Used for VAAPI interop.</para>
        /// <para>Set to -1 if invalid.</para>
        /// </summary>
        public int render_fd;
    }
    
    
    
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public unsafe delegate IntPtr MpvOpenglInitParams_get_proc_addressCallback(IntPtr ctx, [MarshalAs(UnmanagedType.LPUTF8Str)]string name);
}
